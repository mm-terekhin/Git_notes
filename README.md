# Git_notes

* ```git init``` - команда инициализации репозитория в текущей папке.

* ```git clone path``` — команда, которая клонирует удалённый репозиторий.

* ```git remote add origin path``` — команда, которая устанавливает в настройках локального репозитория путь к удалённому репозиторию.

* ```git remote show origin``` - команда позволяет просмотреть, какие локальные ветки связаны с ветками удалённого репозитория и каков их статус.

* ```git remote -v``` - выводит информацию о путях к вашим удалённым репозиториям.

* ```git remote remove origin``` - удалить репозиторий.

* ```git remote set-url origin new-path``` - поменять путь к репозиторию.

* ```git status``` — показывает текущее состояние файлов в репозитории. 

* ```git log``` — показывает историю изменений.

* ```.gitignore``` - файл где перечислены папки и файлы репозитория, которые Git не должен отслеживать и синхронизировать их состояние.

* ```git diff``` - позволяет посмотреть, что изменилось с последнего коммита.

* ```git fetch``` - обновляет информацию о всех удалённых ветках, не изменяет файлы и ветки в рабочем каталоге. 
Позволяет просмотреть все изменения и обновления перед их интеграцией. 

* ```git blame``` - позволяет увидеть, какие изменения какими пользователями и в рамках каких коммитов вносились в тот или иной файл. 

## Модели ветвления ##

__Trunk-Based Development__ - разработчики трудятся над одной веткой (```master```) и не создают отдельные, а клонируют мастер-ветку к себе на компьютер, вносят изменения и потом вливают их обратно в ```master```.

__Feature/Issue Branch Workflow__ - под каждую фичу или задачу создаётся своя ветка, в которой ведётся разработка, и по окончании ветка вливается в ```master```.

__Gitflow__ -  в проекте используют две основные ветки: ```master``` и ```develop```. В ветке ```master``` хранится стабильная версия программного продукта, которая готова для выпуска в production (прод). В ветке ```develop``` хранится актуальная версия кода с последними изменениями, которые ещё не были выпущены в прод. От ветки ```develop``` разработчики отводят другие ветки под конкретные задачи.

## Merge и rebase ##

```git merge``` — помёржит изменения из другой ветки, создав отдельный merge-коммит.

```git rebase``` — заново наложит наши коммиты поверх той ветки, которую подтягиваем в свою.

## Squash — уборка коммитов ##

```git rebase -i``` — это интерактивная команда Git, которая позволяет изменять порядок и применять изменения коммитов ветки в интерактивном режиме.

```$ git rebase -i HEAD~3``` 

* ```HEAD``` — ссылка на последний коммит.

* ```~n``` — от последнего коммита взять n коммитов.

__Ещё одно применение squash — схлопывание коммитов при мёрже__

```squash``` полезен, когда вы мёржите ветку в main. В отдельной ветке вы можете вести разработку как угодно, но для сохранения более понятной и чистой истории основной ветки при мёрже ветки можно схлопнуть все коммиты в один.

```$ git merge --squash target_branch_name```

## Cherry-pick — выборочный мёрж ##

```git cherry-pick``` — команда Git, которая переносит коммит(ы) из одной ветки в другую.
Она берёт изменения, которые были сделаны в указанном коммите, и накладывает на текущую ветку.

```git cherry-pick 4215d16f17f52e5279f84df6b89dd3d7b423cac4```

## Отмена несохранённых изменений ##

* ```git restore index.html``` - вернуть файл к исходному состоянию.

* ```git restore --staged styles.css``` - вернуть файл в индексе к исходному состоянию.

* ```git clean -f``` - удаляет те файлы, которые не отслеживаются и ещё ни разу не добавлялись в индекс — файлы, которые находятся в состоянии “untracked”. 

* ```git rm --cached file_name``` - удаляет файл из отслеживания

## Revert и reset ##

```$ git revert``` используется для добавления нового коммита, который отменяет изменения, сделанные в другом коммите.

```$ git revert <comit> <comit>...``` - отмена нескольких коммитов

Чтобы не засорять историю и при необходимости быстро посмотреть, что изменилось, ```revert``` можно сделать в один коммит с помощью ключа ```-n```. 
Нужно не забыть потом закоммитить изменения: ```$ git revert -n <comit> <comit>...```

Если нужно удалить несколько коммитов, то ещё можно использовать вот такую запись:
```$ git revert -n HEAD~5..HEAD~2``` (первый коммит..последний коммит).

```$ git reset``` используется для отмены изменений, применённых в коммите, и возвращения к предыдущему состоянию. По сути, перемещает ```HEAD``` на заданный коммит.

* ```--soft``` — изменения не удаляются, а только помещаются в рабочий каталог. C помощью этой опции вы можете отменить коммит и оставить изменения в рабочем каталоге.

* ```--mixed```, в отличие от ```--soft```, удаляет коммит и возвращает изменения в индекс. То есть нужно будет выполнить команду git add перед следующим коммитом.

* ```--hard``` — крайний вариант. Он удаляет не только коммит, но и все изменения, внесённые в историю коммитов до него. Осторожно, восстановить данные после применения этой команды нельзя.

```git reset --merge hash``` - отмена слияния до коммита до которого вам нужно откатиться.

```git merge --abort``` - отменить слияние, которое не произошло из-за конфликтов

## Откладывание изменений ##

* ```git stash``` - позволяет временно отложить сделанные изменения.

* ```git stash pop``` - вернуть ранние изменения из отложенных командой.

* ```git stash drop``` - отменить последнюю порцию отложенных изменений командой.

